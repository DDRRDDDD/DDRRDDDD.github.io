#### 🚨 직면했던 과제
> * **제한된 스토리지 비용 이슈** : 특정 용량 제한을 초과할 때마다 비용이 발생하는 `Supabase`의 과금 구조를 고려했을 때, 원본 이미지를 그대로 업로드하면 스토리지가 조기에 소진되어 불필요한 비용이 발생할 것을 우려했습니다.
> * **압축 연산으로 인한 UI 끊김** : 이미지를 메인 스레드에서 처리하면 압축 연산 부하로 인해 프레임 드랍 현상이 발생할 수 있으며, 이로 인해 쾌적한 사용자 경험을 해칠 우려가 있다고 판단했습니다.
> * **불필요한 중복 압축** : 이미 서버에 업로드된 이미지를 수정/저장할 때, 다시 압축 과정을 거치는 비효율적인 리소스 낭비가 발생했습니다.

#### ⚙️ 아키텍처
![이미지 아키텍처](assets/md/my-turn/image_resource_architecture_diagram.png "이미지 아키텍처")

#### 🛠 문제 해결 및 구현 과정
> **💡 Isolate 기반의 비동기 WebP 압축**
> * **WebP 포맷 채택** : `JPEG` 대비 용량은 작으면서 품질은 유지되는 `WebP` 포맷을 도입하여 스토리지 효율을 극대화했습니다.
> * **Isolate 병렬 처리** : 무거운 이미지 압축 연산을 별도의 Isolate(백그라운드 스레드)로 격리하여 실행함으로써, 압축이 진행되는 동안에도 메인 UI 스레드가 멈추지 않는 것을 보장했습니다.
>
> **💡 타입 시스템을 활용한 중복 방지 설계**
> * **ImageResource 추상화** : 이미지의 출처를 명확히 구분하기 위해 `ImageResource`를 추상화하고, `FileImageResource`(로컬/압축필요)와 `UrlImageResource`(서버/압축불필요)로 타입을 세분화했습니다.
> * **타입 기반 로직 분기** : 데이터 저장 시점에 객체의 타입을 검사하여, 로컬 파일인 경우에만 압축 및 업로드를 수행하고, 이미 서버에 있는 이미지는 로직을 건너뛰도록 설계해 불필요한 연산을 원천 차단했습니다.
> * **커스텀 이미지 프로바이더** : 각 타입(`File`,`Url`)에 맞춰 최적화된 리사이징과 캐싱 전략을 수행하는 전용 `ImageProvider`를 설계하여 메모리 사용량을 최적화했습니다.

#### 📈 성과/개선
> * **스토리지 용량 효율화** : 원본 대비 평균 **40 ~ 50% 이상**의 용량 절감하여, `Supabase`의 기본 제공 용량 제한 내에서 스토리지를 최대한으로 활용할 수 있게 되었습니다.
> * **반응성 향상** : 압축 연산 중에도 스크롤이나 애니메이션이 끊기지 않는 매끄러운 사용자 경험을 확보했습니다.
> * **유지보수성 향상** : 복잡한 파일 검사 로직 대신 **명확한 타입 분기**를 사용하여 코드의 가독성과 안정성을 높였습니다.