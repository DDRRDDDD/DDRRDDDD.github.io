#### 🚨 직면했던 과제
> * **런타임 파싱의 한계** : XML 기반의 SVG를 앱 실행 중에 파싱하고 래스터화하는 과정에서 심각한 UI Jank와 발열이 발생했습니다. 특히 리스트 스크롤 시 프레임 드랍이 빈번했습니다.
> * **라이브러리의 기능 부재** : 성능 개선을 위해 도입한 vector_graphics 패키지는 로컬 에셋 로딩에 최적화되어 있어, 네트워크상의 벡터 데이터를 캐싱하는 기능이 전무했습니다.
> * **동적 카테고리 확장성 요구** : 앱 운영 중 카테고리 아이콘이 늘어날 수 있어 로컬 에셋이 아닌 서버관리가 필수적이었으나, 매번 네트워크 요청을 날리는 것은 비효율적이었습니다.

#### 🛠 문제 해결 및 구현 과정
> **💡 컴파일 방식 도입**
> * **바이너리 포맷 최적화** : 런타임에 XML을 해석하는 대신, 빌드 타임(혹은 업로드 전)에 미리 최적화된 바이너리 포맷으로 컴파일하는 `vector_graphics` 방식을 도입했습니다.
> * **수동 컴파일 파이프라인** : 자동화 툴(SVGO)의 압축으로 인한 이미지 깨짐 문제를 방지하기 위해, 수동으로 정교하게 압축 및 컴파일한 바이너리 파일을 서버 스토리지에 업로드하여 렌더링 안정성을 확보했습니다.
>
> **💡 커스텀 네트워크 캐싱 레이어 구현**
> * **라이브러리 벤치마킹** : `cached_network_image` 패키지의 캐시 로직(LRU 알고리즘, 파일 시스템 관리)을 분석하고 벤치마킹했습니다.
> * **Custom BytesLoader 구현** : `vector_graphics`가 네트워크 데이터를 로드할 때, 로컬 디스크에 저장된 캐시가 있으면 즉시 반환하고 없으면 다운로드 후 저장하는 `CachedNetworkCacheLoader`를 직접 구현하여 네트워크 의존성을 제거했습니다.

#### 📈 성과/개선
> * **런타임 연산 비용 제거** : 파싱 연산을 미리 수행해둔 덕분에, 복잡한 벡터 아이콘을 수십 개 렌더링해도 발열 없이 부드러운 스크롤을 유지했습니다.
> * **네트워크 비용 절감 및 로딩 최적화** : 첫 로딩 이후에는 **네트워크 지연 없는 즉각적인 렌더링**을 달성하여 사용자 경험을 대폭 개선했습니다.
> * **이미지 렌더링 비용 90% 절감** : Raster Thread의 점유 시간을 1/10 수준으로 단축시키며 정량적인 성능 목표를 달성했습니다.

#### 🔗 블로그 링크
* [SVG 10배 빠르게 사용하기](https://velog.io/@ddrrdddd/Flutter-SVG-10%EB%B0%B0-%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0)